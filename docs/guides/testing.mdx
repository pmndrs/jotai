---
title: Testing
description: How to test your code using Jotai
nav: 3.08
---

We echo the [guiding principles of Testing library](https://testing-library.com/docs/guiding-principles/):

- "The more your tests resemble the way your software is used, the more confidence they can give you."

We encourage you to write tests, like the user would interact with your atoms and components,
therefore treating Jotai as an implementation detail.

Here's an example using [React testing library](https://github.com/testing-library/react-testing-library):

`Counter.tsx`:

```tsx
import { atom, useAtom } from 'jotai'

const countAtom = atom(0)

export function Counter() {
  const [count, setCount] = useAtom(countAtom)
  return (
    <h1>
      <p>{count}</p>
      <button onClick={() => setCount((c) => c + 1)}>one up</button>
    </h1>
  )
}
```

`Counter.test.tsx`:

```tsx
import React from 'react'
import { render, screen, fireEvent } from '@testing-library/react'
import { Counter } from './Counter'

test('should increment counter', () => {
  // Arrange
  render(<Counter />)

  const counter = screen.getByText('0')
  const incrementButton = screen.getByText('one up')
  // Act
  fireEvent.click(incrementButton)
  // Assert
  expect(counter.textContent).toEqual('1')
})
```

## Injected Values

You may want to setup atom values before starting some tests, for example you may want to limit your counter to 100, and test this behaviour. So you would need to set the current value to 100 to check if incrementing is prevented as expected.
In order to do that, simply use a [Provider](..api/core#provider), and export your atom for to be filled-in.

```tsx
import React from 'react'
import { render, screen, fireEvent } from '@testing-library/react'
import { countAtom, Counter } from './Counter'
import { Provider } from 'jotai'

const CounterProvider = () => {
  return (
    <Provider initialValues={[[countAtom, 1]]}>
      <Counter />
    </Provider>
  )
}

test('should not increment on max (100)', () => {
  render(<CounterProvider />)

  const counter = screen.getByText('100')
  const incrementButton = screen.getByText('one up')
  fireEvent.click(incrementButton)
  expect(counter.textContent).toEqual('100')
})
```

## Custom hooks

If you have complex atoms, sometimes you want to test them in isolation.

For that, you can use [React Hooks Testing Library](https://github.com/testing-library/react-hooks-testing-library).
Here's an example below:

`countAtom.ts`:

```tsx
import { useAtom } from 'jotai'
import { atomWithReducer } from 'jotai/utils'

const reducer = (state: number, action?: 'INCREASE' | 'DECREASE') => {
  switch (action) {
    case 'INCREASE':
      return state + 1
    case 'DECREASE':
      return state - 1
    case undefined:
      return state
  }
}
export const countAtom = atomWithReducer(0, reducer)
```

`countAtom.test.ts`:

```tsx
import { renderHook, act } from '@testing-library/react-hooks'
import { useAtom } from 'jotai'
import { countAtom } from './countAtom'

test('should increment counter', () => {
  const { result } = renderHook(() => useAtom(countAtom))

  act(() => {
    result.current[1]('INCREASE')
  })

  expect(result.current[0]).toBe(1)
})
```

# Example with React-Native

Of course, you can test React-Native components too the same way, with or without `Provider`.

```tsx
import React from 'react'
import { render, fireEvent } from '@testing-library/react-native'
import { Counter } from './counter'

test('should increment counter', () => {
  // Arrange
  const { getByText } = render(<Counter />)
  const counter = getByText('0')
  const incrementButton = getByText('one up')
  // Act
  fireEvent.press(incrementButton)
  // Assert
  expect(counter.props.children.toString()).toEqual('1')
})
```
