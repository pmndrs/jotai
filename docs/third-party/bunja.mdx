---
title: Bunja
description: State Lifetime Manager
nav: 5.03
keywords: scope,di,raii,lifetime
---

[Bunja](https://github.com/disjukr/bunja) is lightweight State Lifetime Manager.

It provides an RAII wrapper for jōtai atoms.

---

See also:

- [Bunja README](https://github.com/disjukr/bunja/blob/main/README.md)
- [Presentations](https://github.com/disjukr/bunja/tree/main/presentations)

## install

```
npm install bunja
```

### Defining a Bunja

You can define a bunja using the `bunja` function.

When you access the defined bunja with the `useBunja` hook, a bunja instance is created.

If all components in the render tree that refer to the bunja disappear, the bunja instance is automatically destroyed.

If you want to trigger effects when the lifetime of a bunja starts and ends, you can use the `bunja.effect` field.

```ts
import { bunja } from 'bunja'
import { useBunja } from 'bunja/react'

const countBunja = bunja([], () => {
  const countAtom = atom(0)
  return {
    countAtom,
    [bunja.effect]() {
      console.log('mounted')
      return () => console.log('unmounted')
    },
  }
})

function MyComponent() {
  const { countAtom } = useBunja(countBunja)
  const [count, setCount] = useAtom(countAtom)
  // Your component logic here
}
```

### Defining a Bunja that relies on other Bunja

If you want to manage a state with a broad lifetime and another state with a narrower lifetime, you can create a (narrower) bunja that depends on a (broader) bunja.

For example, you can think of a bunja that manages the WebSocket connection and disconnection, and another bunja that subscribes to a specific resource over the connected WebSocket.

In an application composed of multiple pages, you might want to subscribe to the Foo resource on page A and the Bar resource on page B, while using the same WebSocket connection regardless of which page you're on.

In such a case, you can write the following code.

```ts
// To simplify the example, code for buffering and reconnection has been omitted.
const websocketBunja = bunja([], () => {
  let socket
  const send = (message) => socket.send(JSON.stringify(message))

  const emitter = new EventEmitter()
  const on = (handler) => {
    emitter.on('message', handler)
    return () => emitter.off('message', handler)
  }

  return {
    send,
    on,
    [bunja.effect]() {
      socket = new WebSocket('...')
      socket.onmessage = (e) => emitter.emit('message', JSON.parse(e.data))
      return () => socket.close()
    },
  }
})

const resourceFooBunja = bunja([websocketBunja], ({ send, on }) => {
  const resourceFooAtom = atom()
  return {
    resourceFooAtom,
    [bunja.effect]() {
      const off = on((message) => {
        if (message.type === 'foo') store.set(resourceAtom, message.value)
      })
      send('subscribe-foo')
      return () => {
        send('unsubscribe-foo')
        off()
      }
    },
  }
})

const resourceBarBunja = bunja([websocketBunja], ({ send, on }) => {
  const resourceBarAtom = atom()
  // ...
})

function PageA() {
  const { resourceFooAtom } = useBunja(resourceFooBunja)
  const resourceFoo = useAtomValue(resourceFooAtom)
  // ...
}

function PageB() {
  const { resourceBarAtom } = useBunja(resourceBarBunja)
  const resourceBar = useAtomValue(resourceBarAtom)
  // ...
}
```

Notice that `websocketBunja` is not directly `useBunja`-ed.
When you `useBunja` either `resourceFooBunja` or `resourceBarBunja`, since they depend on `websocketBunja`,
it has the same effect as if `websocketBunja` were also `useBunja`-ed.

> When a bunja starts, the initialization effect of the bunja with a broader lifetime is called first.
> Similarly, when a bunja ends, the cleanup effect of the bunja with the broader lifetime is called first.
> This behavior is aligned with how React's `useEffect` cleanup function is invoked, where the parent’s cleanup is executed before the child’s in the render tree.
>
> See: https://github.com/facebook/react/issues/16728

### Dependency injection using Scope

You can use a bunja for local state management.

When you specify a scope as a dependency of the bunja, separate bunja instances are created based on the values injected into the scope.

```ts
import { bunja, createScope } from 'bunja'

const UrlScope = createScope()

const fetchBunja = bunja([UrlScope], (url) => {
  const queryAtom = atomWithQuery((get) => ({
    queryKey: [url],
    queryFn: async () => (await fetch(url)).json(),
  }))
  return { queryAtom }
})
```

#### Injecting dependencies via React context

If you bind a scope to a React context, bunjas that depend on the scope can retrieve values from the corresponding React context.

In the example below, there are two React instances (`<ChildComponent />`) that reference the same `fetchBunja`, but since each looks at a different context value, two separate bunja instances are also created.

```tsx
import { createContext } from 'react'
import { bunja, createScope } from 'bunja'
import { bindScope } from 'bunja/react'

const UrlContext = createContext('https://example.com/')
const UrlScope = createScope()
bindScope(UrlScope, UrlContext)

const fetchBunja = bunja([UrlScope], (url) => {
  const queryAtom = atomWithQuery((get) => ({
    queryKey: [url],
    queryFn: async () => (await fetch(url)).json(),
  }))
  return { queryAtom }
})

function ParentComponent() {
  return (
    <>
      <UrlContext.Provider value="https://example.com/foo">
        <ChildComponent />
      </UrlContext.Provider>
      <UrlContext.Provider value="https://example.com/bar">
        <ChildComponent />
      </UrlContext.Provider>
    </>
  )
}

function ChildComponent() {
  const { queryAtom } = useBunja(fetchBunja)
  const { data, isPending, isError } = useAtomValue(queryAtom)
  // Your component logic here
}
```

You can use the `createScopeFromContext` function to handle both the creation of the scope and the binding to the context in one step.

```ts
import { createContext } from 'react'
import { createScopeFromContext } from 'bunja/react'

const UrlContext = createContext('https://example.com/')
const UrlScope = createScopeFromContext(UrlContext)
```

#### Injecting dependencies directly into the scope

You might want to use a bunja directly within a React component where the values to be injected into the scope are created.

In such cases, you can use the inject function to inject values into the scope without wrapping the context separately.

```tsx
import { inject } from 'bunja/react'

function MyComponent() {
  const { queryAtom } = useBunja(
    fetchBunja,
    inject([[UrlScope, 'https://example.com/']]),
  )
  const { data, isPending, isError } = useAtomValue(queryAtom)
  // Your component logic here
}
```
